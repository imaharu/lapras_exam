# ER図

```
@startuml
entity 注文 {
申込日時
}

entity 注文詳細 {
ブランド名
購入価格
原価
購入量
}

entity ブレンド茶葉 {
  __
タイトル
説明
状態
}

entity ブレンド素材 {
  __
  構成比率
}

entity 問屋価格値付け {
  --
  問屋価格
  値付け日時
}

entity 茶葉 {
  --
渋み
甘み
苦味
}

entity 産地 {
}

entity 仕入れ先 {
  --
}

entity 自社在庫 {
  --
  在庫数
}

entity 預け入れ在庫 {
--
在庫<FK>
ユーザー<FK>
在庫数
}

entity 預け入れ在庫割り振り優先度 {
--
優先度
}

entity 販売価格 {
  --
  販売価格
  原価
}

entity 茶葉カテゴリー {
}

entity カテゴリー {
}

entity ユーザー {
--
名前
}

entity 販売利益請求 {
--
販売利益
支払済ブラグ
}

entity ブレンド茶葉構成 {
}


ブレンド茶葉 ||..|{ 販売価格
ユーザー ||..|{ ブレンド茶葉
ユーザー ||..|{ 注文
注文 ||..|{ 注文詳細
注文 ||..|| 販売利益請求
ユーザー ||..|{ 販売利益請求
ブレンド茶葉構成 ||..|{  ブレンド素材
ブレンド茶葉 ||..|{ ブレンド茶葉構成
茶葉 ||..|{ ブレンド素材
茶葉 ||..|{ カテゴリー
茶葉カテゴリー ||..|{ カテゴリー
茶葉 ||..|{ 問屋価格値付け
茶葉 ||..|| 自社在庫
自社在庫 ||..|{ 預け入れ在庫
ユーザー ||..|{  預け入れ在庫
茶葉 ||..|| 産地
ユーザー ||..|| 預け入れ在庫割り振り優先度
仕入れ先 ||..|{ 問屋価格値付け
注文詳細 ||..|| ブレンド茶葉構成
@enduml
```

# RDB以外で解決する箇所

- Redis
  - 揮発してよいデータであるCartに使用
    - LocalStorageを利用してもいいかも。AmazonのCartがブラウザ間で引継ぎしているのか調べる
- Elasticsearch
  - ブレンド茶葉のレコード数 = 1000万(ユーザー数) x 0.5 x 100(平均ブレンド数)と多いのでRDBで検索すると売上が伸びにくいため

# メモ

問屋と仕入れで表現の揺れがある

販売価格を別テーブルに切り出すことでロックを取りやすくなる

ブレンド茶葉の公開状態は、テーブルを分けることで価値を生むことはないと思ったのでカラムに追加

ブランド茶葉の名前は変更する。購入者は注文履歴を見た時、購入時の名前が表示されてほしいと思うので注文詳細にブランド名を追加

メモ: データ永続化や関連を付けるか基準

- データが金につながるか
- 揮発性

メモ: 在庫1つ1つをレコードとして扱うと、パフォーマンスが出るので修正したい

購入ページに遷移したらアプリケーションロックとデータベースロックの組み合わせでパフォーマンスをあげる。ロックをするなら、expireすることを考える必要あり。ロック単位を制限するようなmoduleを作るのが一般的な設計スタイルなはず (poeaaの復習をする)

在庫数が十分に多い時は、ロックを無視するみたいな機能があれば売上を上げられる気がする。が決済の待ちや失敗が再購入にどれくらい関与しているか次第

1つ1つ ⇒ ダメそう

在庫

- 万引きなどで在庫がない場合がある
    - 現実世界だと棚卸しという作業がある
        - 実地棚卸
        - システムに登録されている在庫は、ある**はず**の在庫
    - 在庫があるサービスでは、どうなんだろ？
- 先に在庫を割り当てておく
- 作成者一人一人を店舗と考える。
    - ⇒ 預け入れ ⇒ 回収

在庫について

- 棚卸減耗費
- 預け在庫
    - [https://www.smartmat.io/column/inventory_contorol/8079](https://www.smartmat.io/column/inventory_contorol/8079)

version管理